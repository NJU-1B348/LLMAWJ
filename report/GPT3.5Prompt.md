# GPT3.5 静态分析警报验证 Prompt 设计

## 目标

通过提供统一格式的处理后的静态分析报告（以下称为IR格式），试图让GPT给出警报的正确性判断，同时给出警报为真的置信度估计。后续可以通过警报的置信度估计，对警报为真的可能性进行排序。

## IR格式

```json
{
    "DefectType": "Never Free",     //The class of this alarm.
    "Location": {                   //The location of this alarm. including ln:line cl:column fl:file_path
        "ln": 358,
        "cl": 12,
        "fl": "httpd-2.4.23/server/util_script.c"
    },
    "Function": "original_uri",     //The name of the function where the alarm occurs.
    "Description": {},              //The alarm description generated. Usually empty. When the class is "Partial Leak", it contains "ConditionalFreePath" which contains information of each conditional flow.
    "Events": [],                   //Not used.
    "Var": [                        
        "first"
    ],                              //The posible variables which caused the alarm. If more than one is given, you need to judge which is the real one.
    "CodeNear": [
        "}",
        "while (apr_isspace(*first)) {",
        "++first;                /*   and the space(s)   */"
    ],                              //The codes around the line of the alarm.
    "SuccessTransform": "True",     //If this value is "False", you can give up analyzing this alarm.
    "TransformMessage": ""          //You do not need to care about this.
}
```

## Prompt

### Prompt 1

```prompt
Dear ChatGPT, I seek your expertise in analyzing reports from static analysis tools, specifically focusing on code written in C/C++. 

The cases that i will provide to you are about memory leaks in C/C++. Warnings are generated by static analysis tools because they detect potential memory leaks in the code. In most cases, they have found pointers that are not freed after they are no longer needed. But sometimes these warnings can be wrong. 

For example, the pointer may be used in a loop and not freed until the loop ends, but the pointer is not actually connected to any object allocation. 

Another example, if two pointers point to the same object, and one of them is freed, the other pointer will still be valid. But the static analysis tool may not be able to detect this and will report a memory leak.

These are just example cases to illustrate the complexity of static analysis and why the warnings can be wrong, and there are still more cases that static analysis tools will make fake warnings. You need to evaluate the accuracy of the warnings and use the information I provide to determine whether static analysis tools have made mistakes like this or not.

Your task:

For each case presented (one error reported at a time), evaluate the accuracy of the findings and elucidate whether they are true or not. Besides giving a result of True or False, provide the chance in 0.00 - 1.00 that this  warning is True. For example, if you are sure this warning is true, then 1.00, if you are sure this warning is false, then 0.00. Provide detailed explanations behind your analyses. Your insights will be invaluable in validating the results and enhancing our understanding of the codebase. Thank you!
```

### Prompt 2

```prompt
First of all, try to understand the format of my report:
//A Block of Alarm.
    {
        "DefectType": "Never Free",     //The class of this alarm.
        "Location": {                   //The location of this alarm. including ln:line cl:column fl:file_path
            "ln": 358,
            "cl": 12,
            "fl": "httpd-2.4.23/server/util_script.c"
        },
        "Function": "original_uri",     //The name of the function where the alarm occurs.
        "Description": {},              //The alarm description generated. Usually empty. When the class is "Partial Leak", it contains "ConditionalFreePath" which contains information of each conditional flow.
        "Events": [],                   //Not used.
        "Var": [                        
            "first"
        ],                              //The posible variables which caused the alarm. If more than one is given, you need to judge which is the real one.
        "CodeNear": [
            "}",
            "while (apr_isspace(*first)) {",
            "++first;                /*   and the space(s)   */"
        ],                              //The codes around the line of the alarm.
        "SuccessTransform": "True",     //If this value is "False", you can give up analyzing this alarm.
        "TransformMessage": ""          //You do not need to care about this.
    }

above is an example,you don't need to analyse it and i will give you one type of report at a time next
notice that i will only give you a few lines of codes near the line where the report of error is, and you need to tell me the report is accurate or not more likely **at the beginning of your answer**. The result must be a stressed word in your answer but dont forget your analysis as well
```

### Prompt 3

```prompt
Then, I need you to understand that your output should be in json format, and the format is provided below:

{
    "Judge": "False",  // this warning is true or false
    "Chance that the warning is true": 0.20, // the chance that this warning is true. For example, if you are sure this warning is true, then 1.00, if you are sure this warning is false, then 0.00.
    "Explanation": "This warning is false because...", // the explanation of why this warning is true or false
    "Other": "" // other information, if you need more information or you cannot deal with it, please mention it here.
}

If you understand all of what I said, please wait for the cases I will give you.
```

### Prompt 4

*This prompt will be your case in IR format.*

## 一些问题与探索

1. 为什么让GPT3.5给出警报正确的置信度：
    因为GPT在面对简单的二元判断的时候，给出的结果是非常笼统的。如果加入置信度，可以让我们定量地对GPT的判断进行评估与排序。这会方便我们得到GPT处理的结果后，优先对警报真实性置信度高的那些警报进行处理。

2. 在向GPT3.5输入上述Prompt之后，如果连续的输入待分析的case，GPT3.5对于首先输入的1-2个case的判断完全正确，而对于后续的case判断会出现的大面积的错误：
    我判断是因为GPT的后续输出收到了越来越多输入case的影响，导致了GPT的输出结果出现随机性。这个问题的解决方案是：在每次输入新的case之前，新建一个GPT3.5的Chat，同时重新输入Prompt1-3，然后输入新的case。这样可以最大程度地保证GPT3.5在输出每一个case的判断时，不受到其他case的影响。

3. 同样是上面描述的问题，GPT3.5在输入更多的case之后，并没有因为前面case的判断而积累经验。而是出现了对同样的case的判断出现了不一致的情况，例如对于以下两个警报：
    **Warning 1**
    ```json
    {
        "DefectType": "Never Free",
        "Location": {
            "ln": 358,
            "cl": 12,
            "fl": "httpd-2.4.23/server/util_script.c"
        },
        "Function": "original_uri",
        "Description": {},
        "Events": [],
        "Var": [
            "first"
        ],
        "CodeNear": [
            "}",
            "while (apr_isspace(*first)) {",
            "++first;                /*   and the space(s)   */"
        ],
        "SuccessTransform": "True",
        "TransformMessage": ""
    }
    ```

    **Warning 2**
    ```json
    {
        "DefectType": "Never Free",
        "Location": {
            "ln": 1380,
            "cl": 31,
            "fl": "util.c"
        },
        "Function": "find_list_item",
        "Description": {},
        "Events": [],
        "Var": [
            "ptr"
        ],
        "CodeNear": [
            "/* Find first non-comma, non-whitespace byte */",
            "while (*ptr == ',' || apr_isspace(*ptr)) {",
            "++ptr;"
        ],
        "SuccessTransform": "True",
        "TransformMessage": ""
    }
    ```

    GPT给出了截然不同的两种回答，分别是：

    **Output 1:**  

    **False**  
    Analyzing the provided report, which indicates a "Never Free" defect in the "original_uri" function at line 358 in the "httpd-2.4.23/server/util_script.c" file, I find the following reasons:

    1. The reported location is within a loop where `first` is incremented (`++first`). The loop structure suggests that there is an intention to iterate over a sequence, and it doesn't inherently indicate a memory leak.

    2. The provided code snippet indicates that the loop is used to skip whitespace characters (`apr_isspace(*first)`). This kind of loop is common in parsing scenarios, and freeing memory might not be necessary within such a context.

    3. The absence of a clear memory allocation or dynamic memory usage in the provided snippet further diminishes the likelihood of a memory leak.

    Considering these points, I have low confidence in the accuracy of this "Never Free" defect report. The code snippet suggests that the reported issue might be a false positive, and there's no clear evidence of a memory leak in the given context. My confidence level is around **20%**.
    
    
    
    **Output 2:**  
    
    **True**
    
    Analyzing the provided report for the "Never Free" defect in the "ap_size_list_item" function at line 1247 in the "util.c" file, I find the following reasons:
    
    1. The code snippet involves a loop where the pointer `ptr` is incremented (`++ptr`) based on certain conditions, such as the character being a comma or whitespace.
    
    2. The loop does not contain any indication of freeing memory, and there is no evidence of memory deallocation for the variable `ptr`.
    
    3. Given the absence of a corresponding freeing operation and the nature of the loop, it is likely that memory allocated to `ptr` might not be freed, leading to a potential memory leak.
    
    Considering these points, I have high confidence in the accuracy of this "Never Free" defect report. The code snippet suggests a situation where memory allocated to `ptr` may not be properly freed, leading to a potential memory leak. My confidence level is around **80%**.
    
    
    
    而两个警报指示的是同一个类型的问题，即一个指向C风格字符串的指针在循环中被递增，在循环后被直接丢弃，没有释放内存。但实际上该问题中的指针并没有分配内存，知识作为指向字符的指针使用，不存在内存泄漏的问题，正确的结果应该是 **False**。这两个Prompt输入位置有所差异，第一个Prompt是在向GPT解释任务后立即输入的，而第二个Prompt是在已经连续问答多个警报之后的输入，并且该输入周围的输入得到的结果出现了相似的问题。并且，在向GPT提供更多信息，解释该指针的用途之后，GPT不仅没有修改对于该警报的判断，反而将警报真实性置信度提高到了90%。这一系列现象说明GPT在面对连续的警报输入时，不会因为之前的输入与判断积累经验，而是会对先前的指示产生某种程度的遗忘，同时出现随机性较高的回答。
    
    

## 效果

在目前的IR可以提供的信息范围下，GPT3.5对于警报的真实性判断不会出现重大错误，对于我们肉眼根据IR的判断结果，例如指针在循环中的使用，是否分配了内存等问题，GPT3.5的判断结果是基本与我们的判断一致的，并且在上述操作下，回答也基本稳定。对于需要更多信息的警报，GPT3.5只能给出估计，受限于目前的IR，并不能提供进入到某些函数体之后的过程，因此GPT3.5无法给出非常肯定的判断。



## 可以改进的方向

通过对比可以发现，如果能在Prompt1中加入更多Memory Leak误报的情况描述，可以辅助GPT进行更为准确的判断。  

同时，如果能够交互式地提供更多函数题内部的信息，也可以让GPT3.5给出更为准确的判断，但是这件事本身在自动化方面有难度。如果需要自动化地与GPT3.5进行交互，需要根据C/C++语法和语义等，从相应的代码文件中提取GPT3.5需要的信息，这是一个非常复杂的工程。同时这也跳出了IR的范畴，需要更多的信息，例如函数体内部的信息，函数调用关系等。

